require('dotenv').config();
const { Telegraf, Markup } = require('telegraf');
const axios = require('axios');
const phone = require('phone');
const express = require("express");

// Configuration
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const API_KEY = process.env.ONLINESIM_API_KEY;
const BANNER_URL = process.env.BANNER_IMAGE_URL;
const PORT = process.env.PORT || 3000;

// V√©rification des variables d'environnement
if (!BOT_TOKEN || !API_KEY) {
  console.error('Erreur: TELEGRAM_BOT_TOKEN et ONLINESIM_API_KEY doivent √™tre d√©finis dans le fichier .env');
  process.exit(1);
}

// Initialisation du bot
const bot = new Telegraf(BOT_TOKEN);

// Configuration de l'API OnlineSim
const ONLINESIM_BASE_URL = 'https://onlinesim.io/api';
const LANG = 'fr';

// Classe utilitaire pour l'API OnlineSim
class OnlineSimAPI {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }

  // R√©cup√©rer la liste des pays disponibles
  async getCountries() {
    try {
      const response = await axios.get(`${ONLINESIM_BASE_URL}/getFreeCountryList`, {
        params: {
          lang: LANG
        }
      });
      
      if (response.data && response.data.response === 1) {
        return response.data.countries;
      }
      return [];
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des pays:', error.message);
      return [];
    }
  }

  // R√©cup√©rer les num√©ros d'un pays sp√©cifique
  async getCountryNumbers(countryCode) {
    try {
      const response = await axios.get(`${ONLINESIM_BASE_URL}/getFreePhoneList`, {
        params: {
          country: countryCode,
          lang: LANG
        }
      });
      
      if (response.data && response.data.response === 1) {
        return response.data.numbers;
      }
      return [];
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des num√©ros:', error.message);
      return [];
    }
  }

  // R√©cup√©rer les messages d'un num√©ro
  async getNumberMessages(phoneNumber) {
    try {
      const response = await axios.get(`${ONLINESIM_BASE_URL}/getFreeMessageList`, {
        params: {
          phone: phoneNumber,
          lang: LANG
        }
      });
      
      if (response.data && response.data.response === 1) {
        return response.data.messages;
      }
      return [];
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des messages:', error.message);
      return [];
    }
  }

  // Prolonger la location d'un num√©ro (pour les num√©ros payants)
  async extendRent(tzid) {
    try {
      const response = await axios.get(`${ONLINESIM_BASE_URL}/extendRentState`, {
        params: {
          apikey: this.apiKey,
          tzid: tzid,
          extension: 1
        }
      });
      
      return response.data;
    } catch (error) {
      console.error('Erreur lors de la prolongation:', error.message);
      return null;
    }
  }
}

// Initialisation de l'API
const onlineSimAPI = new OnlineSimAPI(API_KEY);

// Fonction pour formater un num√©ro de t√©l√©phone
function formatPhoneNumber(phoneNumber, countryCode) {
  try {
    const formatted = phone(phoneNumber, countryCode);
    if (formatted.isValid) {
      return formatted.phoneNumber;
    }
    return phoneNumber;
  } catch (error) {
    return phoneNumber;
  }
}

// Fonction pour obtenir le drapeau d'un pays √† partir du code
function getCountryFlag(countryCode) {
  if (!countryCode) return 'üè≥';
  
  // Conversion du code de pays en point de code Unicode pour le drapeau
  const base = 127397;
  return countryCode.toUpperCase().replace(/./g, 
    char => String.fromCodePoint(base + char.charCodeAt(0))
  );
}

// Gestionnaire de commande /start et /restart
bot.start(async (ctx) => {
  try {
    if (BANNER_URL) {
      await ctx.replyWithPhoto(BANNER_URL, {
        caption: `‚ÅÄ‚û¥ Bonjour ${ctx.from.first_name || 'Utilisateur'}!\n
Bienvenue sur le Bot Virtual Number OnlineSim\n\n
Envoyez /help pour obtenir de l'aide\n
Envoyez /number pour obtenir un num√©ro virtuel`,
        parse_mode: 'Markdown'
      });
    } else {
      await ctx.reply(`‚ÅÄ‚û¥ Bonjour ${ctx.from.first_name || 'Utilisateur'}!\n
Bienvenue sur le Bot Virtual Number OnlineSim\n\n
Envoyez /help pour obtenir de l'aide\n
Envoyez /number pour obtenir un num√©ro virtuel`);
    }
  } catch (error) {
    console.error('Erreur dans la commande start:', error);
    await ctx.reply('Une erreur est survenue lors du d√©marrage du bot.');
  }
});

bot.command('restart', async (ctx) => {
  await ctx.reply('Red√©marrage du bot...');
  await ctx.reply(`‚ÅÄ‚û¥ Bonjour ${ctx.from.first_name || 'Utilisateur'}!\n
Bienvenue sur le Bot Virtual Number OnlineSim\n\n
Envoyez /help pour obtenir de l'aide\n
Envoyez /number pour obtenir un num√©ro virtuel`);
});

// Gestionnaire de commande /help et /usage
bot.help(async (ctx) => {
  const helpText = `¬∑·¥•¬∑ Virtual Number Bot\n\n
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n
‚òÖ Pour obtenir un nouveau num√©ro, envoyez simplement la commande /number ou utilisez le bouton inline (Renouveler) pour obtenir un nouveau num√©ro.\n\n
‚òÖ Pour obtenir les messages re√ßus, utilisez le bouton inline (Bo√Æte de r√©ception). Cela vous montrera les 5 derniers messages.\n\n
‚òÖ Vous pouvez √©galement v√©rifier le profil Telegram du num√©ro en utilisant le bouton inline (Profil)\n
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n
C'est tout ce que vous devez savoir sur ce bot !`;
  
  await ctx.reply(helpText);
});

bot.command('usage', async (ctx) => {
  await ctx.reply('Commande /usage: voir /help');
});

// Gestionnaire de commande /number
bot.command('number', async (ctx) => {
  try {
    // Message initial
    let message = await ctx.reply('Recherche d\'un num√©ro pour vous...\n\n‚ÅÄ‚û¥ R√©cup√©ration des pays en ligne:');

    // R√©cup√©rer les pays disponibles
    const countries = await onlineSimAPI.getCountries();
    
    if (!countries || countries.length === 0) {
      await ctx.editMessageText('Aucun pays disponible pour le moment. Veuillez r√©essayer plus tard.');
      return;
    }

    await ctx.editMessageText(`Recherche d'un num√©ro al√©atoire pour vous...\n\n‚ÅÄ‚û¥ R√©cup√©ration des pays en ligne:\nTrouv√© ${countries.length} pays\n\n‚ÅÄ‚û¥ Test des num√©ros actifs:`);

    // M√©langer les pays pour un choix al√©atoire
    const shuffledCountries = [...countries].sort(() => Math.random() - 0.5);

    // Parcourir les pays pour trouver un num√©ro actif
    for (const country of shuffledCountries) {
      const countryCode = country.country;
      const countryName = country.country_text;

      // R√©cup√©rer les num√©ros pour ce pays
      const numbers = await onlineSimAPI.getCountryNumbers(countryCode);
      
      if (!numbers || numbers.length === 0) continue;

      // Filtrer les num√©ros actifs (ceux qui ont des messages r√©cents)
      const activeNumbers = [];
      
      for (const number of numbers) {
        // V√©rifier si le num√©ro a des messages r√©cents
        const messages = await onlineSimAPI.getNumberMessages(number.full_number);
        if (messages && messages.length > 0) {
          activeNumbers.push({
            number: number.full_number,
            country: countryCode,
            countryName: countryName,
            messages: messages
          });
        }
      }

      // Si on a trouv√© des num√©ros actifs, en choisir un au hasard
      if (activeNumbers.length > 0) {
        const randomNumber = activeNumbers[Math.floor(Math.random() * activeNumbers.length)];
        
        // Formater le num√©ro
        const formattedNumber = formatPhoneNumber(randomNumber.number, randomNumber.country);
        const flag = getCountryFlag(randomNumber.country);
        
        // Cr√©er les boutons inline
        const keyboard = Markup.inlineKeyboard([
          [
            Markup.button.callback('üì• Bo√Æte de r√©ception', `inbox:${randomNumber.country}:${randomNumber.number}`),
            Markup.button.callback('üîÅ Renouveler', `renew:${randomNumber.country}:${randomNumber.number}`)
          ],
          [
            Markup.button.callback('üë§ Profil', `profile:${randomNumber.country}:${randomNumber.number}`)
          ]
        ]);

        // Mettre √† jour le message avec le num√©ro trouv√©
        await ctx.editMessageText(`${flag} Voici votre num√©ro: ${formattedNumber}\n\nPays: ${randomNumber.countryName}\n\nDerni√®re mise √† jour: ${new Date().toLocaleString()}`, keyboard);
        return;
      }
    }

    // Si aucun num√©ro actif n'a √©t√© trouv√©
    await ctx.editMessageText('Aucun num√©ro actif disponible pour le moment. Veuillez r√©essayer plus tard.');

  } catch (error) {
    console.error('Erreur dans la commande number:', error);
    try {
      await ctx.editMessageText('Une erreur est survenue lors de la recherche d\'un num√©ro. Veuillez r√©essayer.');
    } catch (e) {
      await ctx.reply('Une erreur est survenue lors de la recherche d\'un num√©ro. Veuillez r√©essayer.');
    }
  }
});

// Gestionnaire pour le bouton "Bo√Æte de r√©ception"
bot.action(/inbox:(.+):(.+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const [country, phoneNumber] = ctx.match.slice(1);
    
    // R√©cup√©rer les messages
    const messages = await onlineSimAPI.getNumberMessages(phoneNumber);
    
    if (!messages || messages.length === 0) {
      await ctx.reply('Aucun message trouv√© pour ce num√©ro.');
      return;
    }
    
    // Afficher les 5 derniers messages
    const recentMessages = messages.slice(0, 5);
    let messageText = `üì® Messages pour ${phoneNumber}:\n\n`;
    
    for (const msg of recentMessages) {
      messageText += `‚è∞ ${msg.created_at}\nüìù ${msg.text}\n\n`;
    }
    
    if (messages.length > 5) {
      messageText += `\n... et ${messages.length - 5} autres messages`;
    }
    
    await ctx.reply(messageText);
  } catch (error) {
    console.error('Erreur dans la gestion de la bo√Æte de r√©ception:', error);
    await ctx.answerCbQuery('Erreur lors de la r√©cup√©ration des messages');
  }
});

// Gestionnaire pour le bouton "Renouveler"
bot.action(/renew:(.+):(.+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    // Pour l'instant, on renvoie simplement un nouveau num√©ro
    // Dans une version future, on pourrait utiliser l'API extendRentState pour les num√©ros payants
    await ctx.reply('Fonctionnalit√© de renouvellement en d√©veloppement. Utilisez /number pour un nouveau num√©ro.');
  } catch (error) {
    console.error('Erreur dans la gestion du renouvellement:', error);
    await ctx.answerCbQuery('Erreur lors du renouvellement');
  }
});

// Gestionnaire pour le bouton "Profil"
bot.action(/profile:(.+):(.+)/, async (ctx) => {
  try {
    await ctx.answerCbQuery();
    const [country, phoneNumber] = ctx.match.slice(1);
    
    // R√©cup√©rer les messages pour afficher les derniers SMS
    const messages = await onlineSimAPI.getNumberMessages(phoneNumber);
    
    let profileText = `üë§ Profil pour ${phoneNumber}\n\n`;
    
    if (messages && messages.length > 0) {
      profileText += `Derniers messages:\n\n`;
      const recentMessages = messages.slice(0, 3);
      
      for (const msg of recentMessages) {
        profileText += `‚è∞ ${msg.created_at}\nüìù ${msg.text}\n\n`;
      }
    } else {
      profileText += 'Aucun message re√ßu pour ce num√©ro.';
    }
    
    // Ajouter un bouton pour contacter le num√©ro sur Telegram
    const keyboard = Markup.inlineKeyboard([
      [Markup.button.url('Contacter sur Telegram', `tg://resolve?phone=${phoneNumber}`)]
    ]);
    
    await ctx.reply(profileText, keyboard);
  } catch (error) {
    console.error('Erreur dans la gestion du profil:', error);
    await ctx.answerCbQuery('Erreur lors de la r√©cup√©ration du profil');
  }
});

// Gestion des erreurs
bot.catch((err, ctx) => {
  console.error(`Erreur pour ${ctx.updateType}:`, err);
  ctx.reply('Une erreur est survenue. Veuillez r√©essayer.');
});

// Serveur web pour Render
const app = express();
app.use(express.json());
app.get('/', (req, res) => {
  res.send('ü§ñ Bot est en ligne!');
});

// D√©marrer le bot
app.listen(PORT, () => {
  console.log(`üöÄ Serveur web d√©marr√© sur le port ${PORT}`);
});

// Gestion propre de l'arr√™t
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
